# MAL: Malware Introductory
When analysing malware, it is important to consider the following :

- Point of Entry (PoE) I.e. Was it through spam that our e-mail filtering missed and the user opened the attachment? Let's review our spam filters and train our users better for future prevention!

- What are the indicators that malware has even been executed on a machine? Are there any files, processes, or perhaps any attempt of "un-ordinary" communication?

- How does the malware perform? Does it attempt to infect other devices? Does it encrypt files or install anything like a backdoor / Remote Access Tool (RAT)?

- Most importantly - can we ultimately prevent and/or detect further infection?!


Despite the many variants of malware, attacks can generally be classified into two types: Targeted and Mass Campaign.

### Targeted
A "Targeted" attack is just that - targeted. In most cases, malware attacks that occur this way are created for a specific purpose against a specific target. A great example of this type of purpose could be the DarkHotel malware, whom is designed to steal information such as authentication details from government officials.

### Mass Campaign
On the other hand, the "Mass Campaign" classification can be akin to many real life examples, and is the most common type of attacks. The entire purpose of this type of Malware is to infect as many devices as possible and perform whatever it may - regardless of target. Companies such as Kaspersky to name one, track these campaigns (known as Advanced Persistent Threats (APTs) and often report on their infection rate and indicators, much akin to the real-life spread of a virus from the World Health Organisation (WHO). 


In Summary, there are two categories of fingerprints that malware may leave behind on a Host after an attack:
### Host-Based Signatures
These are generally speaking the results of execution and any persistence performed by the Malware. For example, has a file been encrypted? Has any additional software been installed? These are two of many, many host-based signatures that are useful to know to prevent and check against further infection.

### Network-Based Signatures
At an overview, this classification of signatures are the observation of any networking communication taking place during delivery, execution and propagation. For example, in Ransomware, where has the Malware contacted for Bitcoin payments?

### Disassemblers, Decompilers and Debuggers
There are three main functionalities that our tools will provide, those are debugging, disassembling, and decompiling. Disassemblers will translate the program from its bytes on disk or in memory into its assembly code equivalent and present it in an informative way. Decompilers are similar to disassemblers except instead of giving us the assembly, it attempts to recreate the code in C/C++. The downside to decompilers is that they can be inaccurate, or lack information. Because of this, if you're using a decompiler it's a good idea to have the disassembled code next to the decompiled code to check for inaccuracies. Debuggers, alongside disassemblers and decompilers, will allow us to place breakpoints within the program while it's running and analyze registers, memory, statuses, and more. They also allow for changing data in memory while the program is running.

### Prologue
The prologue comes before the body of a function is executed. Not all prologues are the same, but here are three things that can happen and the order they usually happen in.

1. Volatile registers are saved. If there is shadow space available, and the appropriate compilation options are chosen, the shadow space can be used to hold volatile registers. If there is no room in shadow space then registers are pushed onto the stack.
2. Space is allocated for the stack frame by subtracting from RSP. The amount subtracted from RSP can be used to determine the number of function parameters.
3. RSP or RBP may be preserved to be restored later. Since RBP isn't used much for stack purposes in x64 when it gets preserved it's likely not being preserved to keep a stack address safe, rather it's being treated the same as the other volatile registers. In the case that it is being used for stack purposes, you may see something along the lines of mov RSP, RBP which moves RSP to where RBP was at, setting up a new stack frame right next to the previous one.

Generally speaking, it's fine to skim over the function prologue, however, note that it can hint at how many parameters are passed to the function.

### Epilogue
The epilogue is pretty straightforward, it undoes/unwinds any stack-related things, mostly caused by the prologue. The epilogue can be a nice place to double-check you didn't miss anything within the prologue, but it's generally more useless to a reverse engineer than the prologue.
You may see the following in the epilogue:

1. Addition to RSP to restore/delete the stack frame.
2. Restoring registers, usually done by popping registers off the stack which were pushed on the stack during the prologue.
3. Return.

