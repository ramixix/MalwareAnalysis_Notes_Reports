The Windows API provides native functionality to interact with key components of the Windows operating system. Using the Windows API, you can develop applications that run successfully on all versions of Windows while taking advantage of the features and capabilities unique to each version. (Note that this was formerly called the Win32 API. The name Windows API more accurately reflects its roots in 16-bit Windows and its support on 64-bit Windows.)

Programs often need to access or modify Windows subsystems or hardware but are restricted to maintain machine stability. To solve this problem, Microsoft released the Win32 API, a library to interface between user-mode applications and the kernel.

Windows distinguishes hardware access by two distinct modes: user and kernel mode. These modes determine the hardware, kernel, and memory access an application or driver is permitted. API or system calls interface between each mode, sending information to the system to be processed in kernel mode.

![[8_0.png]]

![[8_1.png]]

---
Each API call of the Win32 library resides in memory and requires a pointer to a memory address. The process of obtaining pointers to these functions is obscured because of ASLR (Address Space Layout Randomization) implementations; each language or package has a unique procedure to overcome ASLR. Let's discuss the two most popular implementations: 
- P/Invoke 
- Windows header file.

1. **Windows Header File**
Microsoft has released the Windows header file, also known as the Windows loader, as a direct solution to the problems associated with ASLRâ€™s implementation. Keeping the concept at a high level, at runtime, the loader will determine what calls are being made and create a thunk table to obtain function addresses or pointers. Once the ==windows.h== file is included at the top of an unmanaged program; any Win32 function can be called.

2. 

