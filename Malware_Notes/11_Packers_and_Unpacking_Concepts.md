Packers are used on executables for two main reasons: to shrink programs or to thwart detection or analysis. 

Even though there are a wide variety of packers, they all follow a similar pattern: They transform an executable to create a new executable that stores the transformed executable as data and contains an unpacking stub that is called by the OS. Most packers use a compression algorithm to compress the original executable. A packer designed to make the file difficult to analyze may encrypt the original executable and employ anti-reverse-engineering techniques, such as anti-disassembly, anti-debugging, or anti-VM. Packers can pack the entire executable, including all data and the resource section, or pack only the code and data sections.

### The Unpacking Stub
Nonpacked executables are loaded by the OS. With packed programs, the unpacking stub is loaded by the OS, and then the unpacking stub loads the original program. The code entry point for the executable points to the unpacking stub rather than the original code. The original program is generally stored in one or more extra sections of the file. The unpacking stub is often small, since it does not contribute to the main functionality of the program, and its function is typically simple: unpack the original executable. 

The unpacking stub performs three steps:
- [ decrypt the original executable if it is encrypted ]
- Unpacks the original executable into memory
- Resolves all of the imports of the original executable
- Transfers execution to the original entry point (OEP)

The unpacking stub unpacks the code for each section and copies it into the space that was allocated. The exact unpacking method used depends on the goals of the packer, and it is generally contained within the stub.

#### Resolving Imports
The Windows loader cannot read import information that is packed. For a packed executable, the unpacking stub will resolve the imports. The specific approach depends on the packer.
1. The most common approach is to have the unpacking stub import only the LoadLibrary and GetProcAddress functions. After the unpacking stub unpacks the original executable, it reads the original import information. It will call LoadLibrary for each library, in order to load the DLL into memory, and will then use GetProcAddress to get the address for each function.
2. Another approach is to keep the original import table intact, so that the Windows loader can load the DLLs and the imported functions. This is the simplest approach, since the unpacking stub does not need to resolve the imports. However, static analysis of the packed program will reveal all the original imports, so this approach lacks stealth. Additionally, since the imported functions are stored in plaintext in the executable, the compression possible with this approach is not optimal.
3. A third approach is to keep one import function from each DLL contained in the original import table. This approach will reveal only one function per imported library during analysis, so it’s stealthier than the previous approach, but analysis will still reveal all the libraries that are imported. This approach is simpler for the packer to implement than the first approach, since the libraries do not need to be loaded by the unpacking stub, but the unpacking stub must still resolve the majority of the functions.
4. The final approach is the removal of all imports (including LoadLibrary and GetProcAddress). The packer must find all the functions needed from other libraries without using functions, or it must find LoadLibrary and GetProcAddress, and use them to locate all the other libraries (It is similar to what shellcode must do). The benefit of this approach is that the packed program includes no imports at all, which makes it stealthy. However, in order to use this approach, the unpacking stub must be complex.

#### The Tail Jump
Once the unpacking stub is complete, it must transfer execution to the OEP. The instruction that transfers execution to the OEP is commonly referred to as the **tail jump.**

A jump instruction is the simplest and most popular way to transfer execution. Since it’s so common, many malicious packers will attempt to obscure this function by using a ret or call instruction. Sometimes the tail jump is obscured with OS functions that transfer control, such as NtContinue or ZwContinue.


- ##### packers usually append piece of code called ==stub== to the final executable which will undo the compression and encryption (if it was used) and then run the decompressed or decrypted code. stub detect the compressed and encrypted part because usually that part has some pre and post signature, and if it is encrypted we might also find the key inside the stub that is used for decryption. 
- ##### If malware is ==fully== packed, it can't infect the computer until it is unpacked. But malware developers have come up with some runtime packers that only pack a partial set of the program. So there would be some part of malware which can be run before the main part is unpacked.


### Two Types of Packers
1. Commerical (UPX, ASPACK)
	1. How to detect Commerical packers :
		- Different code at entry point
		- Minimal APIs
2. Custom (parsing PE headers)
	1. How to detect Custom packers:
		- reg + 0x3C


### Unpacking steps :
- Allocate memory for file ( sometimes stub decode the file into its place so there would not be a need for memory allocation )
- Decode file into memory
* Map file into memory state (in this step stub perform the operations that normally loaders perform when a unpack binary file is executed )
	- Allocate memory for unpacked file
	- Copy file's sections to memory
	- Build IAT
	- Fix relocations
	- Apply section permissions (optional)
	- Call entry point


### Things to ask before starting working with a sample:
- Is the malware really packed?
	- What are the evidences of having a packed code?
- Does the malware perform self-injection or remote injection?
- Does the malware perform self-overwriting?
- Where is the payload being written?
- How the payload is going to be executed?
- What are evidenced of having an unpacked code after the unpacking procedure?
- Are there additional packed layers?

### How do we know if a malware is really packed?
- The binary sample has few imported DLLs and functions.
- There are many obfuscated strings.
- Existence of specific system calls.
- Non-standard section names.
- Non-common executable binary sections (only .text/.code section should be executable)
- Unexpected writable sections.
- High entropy sections (usually above 7.0, but not always – this is a weak indicator).
- Substantial difference between the raw size and the virtual size of a section.
- Zero-sized sections.
- Missing APIs related to network communication.
- Lack of essential APIs for the malware functionalities (Crypt* functions in a ransomware, for example).
- Unusual file format and headers.
- Entry-point pointing to other section than .text/.code section.
- Significant size of resource section (.rsrc section) followed by LoadResource( ) function in the code.
- Presence of an overlay.
- Opening it up on IDA Pro and observing a big amount of data or unexplored code on colored bar.
