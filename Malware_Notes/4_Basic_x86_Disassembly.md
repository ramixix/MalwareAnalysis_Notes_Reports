# x86 Disassembly

**Overview:**
<iframe width="560" height="315" src="https://www.youtube.com/embed/rEc-OGzcaKU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
[Crash_Course_in_x86](https://www.youtube.com/embed/rEc-OGzcaKU)

[x86 Assembly Guide](https://www.cs.virginia.edu/~evans/cs216/guides/x86.html)

## Levels of Abstraction 
In traditional computer architecture, a computer system can be represented as several levels of abstraction that create a way of hiding the implementation details. For example, you can run the Windows OS on many different types of hardware, because the underlying hardware is abstracted from the OS.

Figure 4-1 shows the three coding levels involved in malware analysis. Malware authors create programs at the high-level language level and use a compiler to generate machine code to be run by the CPU. Conversely, malware analysts and reverse engineers operate at the low-level language level; we use a disassembler to generate assembly code that we can read and analyze to figure out how a program operates.

![[4_0.png]]
 
 Figure 4-1 shows a simplified model, but computer systems are generally described with the following six different levels of abstraction. We list these levels starting from the bottom. Higher levels of abstraction are placed near the top with more specific concepts underneath, so the lower you get, the less portable the level will be across computer systems. 

1. **Hardware:** The hardware level, the only physical level, consists of electrical circuits that implement complex combinations of logical operators such as XOR, AND, OR, and NOT gates, known as digital logic. Because of its physical nature, hardware cannot be easily manipulated by software.

2. **Microcode:** The microcode level is also known as firmware. Microcode operates only on the exact circuitry for which it was designed. It contains microinstructions that translate from the higher machine-code level to provide a way to interface with the hardware. When performing malware analysis, we usually don’t worry about the microcode because it is often specific to the computer hardware for which it was written.

3. **Machine code:** The machine code level consists of opcodes, hexadecimal digits that tell the processor what you want it to do. Machine code is typically implemented with several microcode instructions so that the underlying hardware can execute the code. Machine code is created when a computer program written in a high-level language is compiled.
 
4. **Low-level languages:** A low-level language is a human-readable version of a computer architecture’s instruction set. The most common low-level language is assembly language. Malware analysts operate at the low-level languages level because the machine code is too difficult for a human to comprehend. We use a disassembler to generate low-level language text, which consists of simple mnemonics such as mov and jmp. Many different dialects of assembly language exist, and we’ll explore each in turn.

> NOTE : Assembly is the highest level language that can be reliably and consistently recovered from machine code when high-level language source code is not available.

5. **High-level languages:** Most computer programmers operate at the level of high-level languages. High-level languages provide strong abstraction from the machine level and make it easy to use programming logic and flow-control mechanisms. High-level languages include C, C++, and others. These languages are typically turned into machine code by a compiler through a process known as compilation. 

6. **Interpreted languages:** Interpreted languages are at the top level. Many programmers use interpreted languages such as C#, Perl, .NET, and Java. The code at this level is not compiled into machine code; instead, it is translated into bytecode. Bytecode is an intermediate representation that is specific to the programming language. Bytecode executes within an interpreter, which is a program that translates bytecode into executable machine code on the fly at runtime. An interpreter provides an automatic level of abstraction when compared to traditional compiled code, because it can handle errors and memory management on its own, independent of the OS.

## Reverse-Engineering
When malware is stored on a disk, it is typically in binary form at the machine code level. As discussed, machine code is the form of code that the computer can run quickly and efficiently. When we disassemble malware, we take the malware binary as input and generate assembly language code as output, usually with a disassembler. 

> Note : Assembly language is actually a class of languages. Each assembly dialect is typically used to program a single family of microprocessors, such as x86, x64, SPARC, PowerPC, MIPS, and ARM. x86 is by far the most popular architecture for PCs.


 --- 
## The x86 Architecture
The internals of most modern computer architectures (including x86) follow the Von Neumann architecture, illustrated in Figure 4-2. It has three hardware components:

- The central processing unit (CPU) executes code.
- The main memory of the system (RAM) stores all data and code.
- An input/output system (I/O) interfaces with devices such as hard drives, keyboards, and monitors.

![[4_1.png]]

As you can see in Figure 4-2, the CPU contains several components: **The control unit gets instructions to execute from RAM using a register ([e|r]ip, the instruction pointer), which stores the address of the instruction to execute. Registers are the CPU’s basic data storage units and are often used to save time so that the CPU doesn’t need to access RAM. The arithmetic logic unit (ALU) executes an instruction fetched from RAM and places the results in registers or memory.** The process of fetching and executing instruction after instruction is repeated as a program runs.

> Note : The x86 architecture is **little-endian**, meaning that multi-byte values are written least significant **byte** first. 
> 
> For example :
> A3 | A2 | A1 | A0    (each A? indicate a byte)
> 
> In x86 (**Stored as Little Endian**):
> A0 | A1 | A2 | A3

---

## Main Memory
The main memory (RAM) for a single program can be dividede into the following four major sections, as shown in Figure 4-3.

![[4_2.png]]
 
- **Data:** This term can be used to refer to a specific section of memory called the data section, which contains values that are put in place when a program is initially loaded. These values are sometimes called static values because they may not change while the program is running, or they may be called global values because they are available to any part of the program. 

- **Code:** Code includes the instructions fetched by the CPU to execute the program’s tasks. The code controls what the program does and how the program’s tasks will be orchestrated.

- **Heap:** The heap is used for dynamic memory during program execution, to create (allocate) new values and eliminate (free) values that the program no longer needs. The heap is referred to as dynamic memory because its contents can change frequently while the program is running.

- **Stack:** The stack is used for local variables and parameters for functions, and to help control program flow. 

> Although the diagram in Figure 4-3 shows the four major sections of memory in a particular order, these pieces may be located throughout memory. For example, there is no guarantee that the stack will be lower than the code or vice versa.

---

## Instructions
Instructions are the building blocks of assembly programs. In x86 assembly, an instruction is made of a mnemonic and zero or more operands. As shown in Table 4-1, the mnemonic is a word that identifies the instruction to execute, such as "mov", which moves data. Operands are typically used to identify information used by the instruction, such as registers or data.

![[4_3.png]]

---

## Opcodes and Endianness
**Each instruction corresponds to opcodes (operation codes) that tell the CPU which operation the program wants to perform.** This book and other sources use the term opcode for the entire machine instruction, although Intel technically defines it much more narrowly.
**Disassemblers translate opcodes into human-readable instructions.** For example, in Table 4-2, you can see that the opcodes are B9 42 00 00 00 for the instruction mov ecx, 0x42. The value 0xB9 corresponds to mov ecx , and 0x42000000 corresponds to the value 0x42.

![[4_4.png]]
 
0x42000000 is treated as the value 0x42 because the x86 architecture uses the little-endian format. **The endianness of data describes whether the most significant (big-endian) or least significant (little-endian) byte is ordered first (at the smallest address) within a larger data item. Changing between endianness is something malware must do during network communication, because network data uses big-endian and an x86 program uses little-endian.** Therefore, the IP address 127.0.0.1 will be represented as 0x7F000001 in big-endian format (over the network) and 0x0100007F in little endian format (locally in memory). As a malware analyst, you must be cognizant of endianness to ensure you don’t accidentally reverse the order of important indicators like an IP address.

---

## Operands
**Operands are used to identify the data used by an instruction.** Three types of operands can be used:

- Immediate operands are fixed values, such as the 0x42 shown in Table 4-1.
 
- Register operands refer to registers, such as ecx in Table 4-1.

- Memory address operands refer to a memory address that contains the value of interest, typically denoted by a value, register, or equation between brackets, such as [eax].

---

## Registers
A register is a small amount of data storage available to the CPU, whose contents can be accessed more quickly than storage available elsewhere. x86 processors have a collection of registers available for use as temporary storage or workspace. Table 4-3 shows the most common x86 registers, which fall into the following four categories:

- General registers are used by the CPU during execution.
- Segment registers are used to track sections of memory.
- Status flags are used to make decisions.
- Instruction pointers are used to keep track of the next instruction to execute.

![[4_5.png]]

Registers can be referenced as either 32,16 or 8 bits in assembly code. For example, EDX is used to reference the full 32-bit register, and DX is used to reference the lower 16 bits of the EDX register.

Four registers (EAX, EBX, ECX, and EDX) can also be referenced as 8-bit values using the lowest 8 bits or the second set of 8 bits. For example, AL is used to reference the lowest 8 bits of the EAX register, and AH is used to reference the second set of 8 bits.

![[4_6.png]]

Table 4-3 lists the possible references for each general register. The EAX register breakdown is illustrated in Figure 4-4. In this example, the 32-bit (4-byte) register EAX contains the value 0xA9DC81F5, and code can reference the data inside EAX in three additional ways: AX (2 bytes) is 0x81F5, AL (1 byte) is 0xF5, and AH (1 byte) is 0x81.

> Note : The register names are mostly historical. For example, EAX used to be called the accumulator since it was used by a number of arithmetic operations, and ECX was known as the counter since it was used to hold a loop index. Whereas most of the registers have lost their special purposes in the modern instruction set, by convention, two are reserved for special purposes - the stack pointer (ESP) and the base pointer (EBP). 

---

## General Registers
The general registers typically store data or memory addresses, and are often used interchangeably to get things accomplished within the program. However, despite being called general registers, they aren’t always used that way. Some x86 instructions use specific registers by definition. For example, the multiplication and division instructions always use EAX and EDX.

In addition to instruction definitions, general registers can be used in a consistent fashion throughout a program. The use of registers in a consistent fashion across compiled code is known as a convention. Knowledge of the conventions used by compilers allows a malware analyst to examine the code more quickly, because time isn’t wasted figuring out the context of how a register is being used. **For example, the EAX generally contains the return value for function calls. Therefore, if you see the EAX  register used immediately after a function call, you are probably seeing the code manipulate the return value.**

---

## Flags
Flags are used to signify the result of the previously executed operation or comparison. For example, if two numbers are compared to each other the flags will reflect the results such as them being even. Flags are contained in a register called EFLAGS (x86) or RFLAGS (x64). The EFLAGS register is a status register. In the x86 architecture, it is 32 bits in size, and each bit is a flag. During execution, each flag is either set (1) or cleared (0) to control CPU operations or indicate the results of a CPU operation. The following flags are most important to malware analysis: 

- **ZF:** The zero flag is set when the result of an operation is equal to zero; otherwise, it is cleared. 
- **CF:** The carry flag is set when the result of an operation is too large or too small for the destination operand; otherwise, it is cleared. (Set when the result requires a carry. It applies to unsigned numbers.)
- **SF:** The sign flag is set when the result of an operation is negative or cleared when the result is positive. This flag is also set when the most significant bit is set after an arithmetic operation.
- **TF:** The trap flag is used for debugging. The x86 processor will execute only one instruction at a time if this flag is set.
- **Overflow Flag (OF):** Set if a signed arithmetic operation is too big for the register to contain. (Set if the result overflows the max size. It applies to signed numbers.)
- **Adjust/Auxiliary Flag (AF)**: Same as the carry flag but for Binary Coded Decimal (BCD) operations.
- **Parity Flag (PF):** Set to 1 if the number of bits set in the last 8 bits is even. (10110100, PF=1; 10110101, PF=0)
---

## EIP, the Instruction Pointer
In x86 architecture, EIP, also known as the instruction pointer or program counter,is a register that contains the memory address of the next instruction to be executed for a program. EIP’s only purpose is to tell the processor what to do next.

>Note: When EIP is corrupted (that is, it points to a memory address that does not contain legitimate program code), the CPU will not be able to fetch legitimate code to execute, so the program running at the time will likely crash. When you control EIP, you can control what is executed by the CPU, which is why attackers attempt to gain control of EIP through exploitation. Generally, attackers must have attack code in memory and then change EIP to point to that code to exploit a system.

---

## Simple Instructions

##### mov — Move (Opcodes: 88, 89, 8A, 8B, 8C, 8E, ...) 
The simplest and most common instruction is "mov", which is used to move data from one location to another. In other words, it’s the instruction for reading and writing to memory. The mov instruction can move data into registers or RAM. The format is **"mov destination, source"**. (Intel syntax: the destination operand is first. AT&T syntax: the source operand is first)

![[4_7_0.png]]

> Note: While register-to-register moves are possible, direct memory-to-memory moves are not. In cases where memory transfers are desired, the source memory contents must first be loaded into a register, then can be stored to the destination memory address.


Table 4-4 contains examples of the mov instruction. Operands surrounded by brackets are treated as memory references to data. For example, [ebx] references the data at the memory address EBX. The final example in Table 4-4 uses an equation to calculate a memory address. This saves space, because it does not require separate instructions to perform the calculation contained within the brackets. **Performing calculations such as this within an instruction is not possible unless you are calculating a memory address. For example, "mov eax, ebx+esi * 4" (without the brackets) is an invalid instruction.**


![[4_7.png]]
 
Another instruction similar to mov is lea, which means “load effective address.” The format of the instruction is lea destination, source. The lea instruction is used to put a memory address into the destination. For example, lea eax, [ebx+8] will put EBX+8 into EAX. In contrast, mov eax, [ebx+8] loads the data at the memory address specified by EBX+8. **Therefore, lea eax, [ebx+8] would be the same as mov eax, ebx+8; however, a mov instruction like that is invalid.**

> Note : Some examples of invalid address calculations include:  
> 
> - ==mov eax, [ebx-ecx]==   ; Minus is not allowed, Can only add(addition operation) register values 
> 
> - ==mov [eax+esi+edi], ebx==  ; At most 2 registers in address computation



Figure 4-5 shows values for registers EAX and EBX on the left and the information contained in memory on the right. EBX is set to 0xB30040. At address 0xB30048 is the value 0x20. The instruction mov eax, [ebx+8] places the value 0x20 (obtained from memory) into EAX, and the instruction lea eax, [ebx+8] places the value 0xB30048 into EAX.

![[4_8.png]]
 
The lea instruction is not used exclusively to refer to memory addresses. It is useful when calculating values, because it requires fewer instructions. For example, it is common to see an instruction such as lea ebx, [eax*5+5], where eax is a number, rather than a memory address. This instruction is the functional equivalent of ebx = (eax+1)*5, but the former is shorter or more efficient for the compiler to use instead of a total of four instructions (for example inc eax; mov ecx, 5; mul ecx; mov ebx, eax).

##### push — Push stack (Opcodes: FF, 89, 8A, 8B, 8C, 8E, ...) 
The push instruction places its operand onto the top of the hardware supported stack in memory. Specifically, push first decrements ESP by 4, then places its operand into the contents of the 32-bit location at address [ESP]. ESP (the stack pointer) is decremented by push since the x86 stack grows down - i.e. the stack grows from high addresses to lower addresses.

![[4_7_1.png]]

##### pop — Pop stack 
The pop instruction removes the 4-byte data element from the top of the hardware-supported stack into the specified operand (i.e. register or memory location). It first moves the 4 bytes located at memory location [SP] into the specified register or memory location, and then increments SP by 4. 

![[4_7_2.png]]

##### lea — Load effective address
The lea instruction places the address specified by its second operand into the register specified by its first operand. Note, the contents of the memory location are not loaded, only the effective address is computed and placed into the register. This is useful for obtaining a pointer into a memory region.

![[4_7_3.png]]

**It's important to note that when working with the LEA instruction, square brackets do not dereference.**
LEA is used to load and calculate addresses, NOT data. It doesn't matter if there are square brackets or not, it's dealing with addresses ONLY. LEA is the instruction that will mess with your head when you're sleep-deprived. ex:

![[4_7_4.png]]

In the example above the address of ==var== is loaded into RAX. This is LEA we are working with, there is no dereferencing. RAX is now acting as a pointer since it holds the address to the variable. Then 12 is moved into the address pointed to by RAX). The address pointed to by RAX is the ==var== variable. If that Assembly was executed, ==var== would be 12. This is all the same as doing ==mov var, 12==.

##### Arithmetic Instructions
x86 assembly includes many instructions for arithmetic, ranging from basic addition and subtraction to logical operators.

Addition or subtraction adds or subtracts a value from a destination operand. The format of the addition instruction is "**add destination, value**". The format of the subtraction instruction is "**sub destination, value**". **The sub instruction modifies two important flags: the zero flag (ZF) and carry flag (CF). The ZF is set if the result is zero, and CF is set if the destination is less than the value subtracted.** The inc and dec instructions increment or decrement a register by one. Table 4-5 shows examples of the addition and subtraction instructions.

![[4_9.png]]

Multiplication and division both act on a predefined register, so the command is simply the instruction, plus the value that the register will be multiplied or divided by. The format of the mul instruction is "**mul reg/mem/value**". Similarly, the format of div instruction is "**div reg/mem/value**". The assignment of the register on which a mul or div instruction acts can occur many instructions earlier, so you might need to search through a program to find it. **The mul value instruction always multiplies eax by value. Therefore, EAX must be set up appropriately before the multiplication occurs. The result is stored as a 64-bit value across two registers: EDX and EAX. EDX stores the most significant 32 bits of the operations, and EAX stores the least significant 32 bits.** Figure 4-6 depicts the values in EDX and EAX when the decimal result of multiplication is 5,000,000,000 and is too large to fit in a single register. 

![[4_10.png]]


The div value instruction does the same thing as mul, except in the opposite direction: **It divides the 64 bits across EDX and EAX by value.** Therefore, the EDX and EAX registers must set up appropriately before the division occurs. **The result of the division operation is stored in EAX, and the remainder is stored in EDX.**

A programmer obtains the remainder of a division operation by using an operation known as modulo, which will be compiled into assembly through the use of the EDX register after the div instruction (since it contains the remainder). Table 4-6 shows examples of the mul and div instructions. 

![[4_11.png]]

ex :
![[4_11_1.png]]

![[4_11_2.png]]

The instructions imul and idiv are the signed versions of the mul and div instructions. IMUL has three forms :

- IMUL reg/mem — Same as MUL (edx:eax = eax * reg/mem)
- IMUL reg1, reg2/mem — reg1 = reg1 * reg2/mem
- IMUL reg1, reg2/mem, imm — reg1 = reg2 * imm

![[4_11_3.png]]

![[4_11_4.png]]

Logical operators such as OR, AND, and XOR are used in x86 architecture. They perform the specified operation between the source and destination operands and store the result in the destination. The xor instruction is frequently encountered in disassembly. **For example, xor eax, eax is a quick way to set the EAX register to zero. This is done for optimization, because this instruction requires only 2 bytes, whereas mov eax, 0 requires 5 bytes.** 

The shr and shl instructions are used to shift registers. The format of the shr instruction is "**shr destination, count**", and the shl instruction has the same format. The shr and shl instructions shift the bits in the destination operand to the right and left, respectively, by the number of bits specified in the count operand. **Bits shifted beyond the destination boundary are first shifted into the CF flag. Zero bits are filled in during the shift.** For example, if you have the binary value 1000 and shift it right by 1, the result is 0100. At the end of the shift instruction, the CF flag contains the last bit shifted out of the destination operand.

The rotation instructions, ror and rol, are similar to the shift instructions, except the shifted bits that “fall off” with the shift operation are rotated to the other end. In other words, during a right rotation (ror) the least significant bits are rotated to the most significant position. Left rotation (rol) is the exact opposite. Table 4-7 displays examples of these instructions.

![[4_12.png]]

**Shifting is often used in place of multiplication as an optimization. Shifting is simpler and faster than multiplication, because you don’t need to set up registers and move data around, as you do for multiplication. The shl eax, 1 instruction computes the same result as multiplying EAX by two. Shifting to the left two bit positions multiplies the operand by four, and shifting to the left three bit positions multiplies the operand by eight. Shifting an operand to the left n bits multiplies it by 2^n.**

During malware analysis, if you encounter a function containing only the instructions xor, or, and, shl, ror, shr, or rol repeatedly and seemingly randomly, you have probably encountered an encryption or compression function.

##### NOP
The final simple instruction, nop, does nothing. When it’s issued, execution simply proceeds to the next instruction. The instruction **nop is actually a pseudonym for xhcg eax, eax**, but since exchanging EAX with itself does nothing, it is popularly referred to as NOP (no operation).
The opcode for this instruction is 0x90. It is commonly used in a NOP sled for buffer overflow attacks, when attackers don’t have perfect control of their exploitation. It provides execution padding, which reduces the risk that the malicious shellcode will start executing in the middle, and therefore malfunction. 

---

## The Stack
Memory for functions, local variables, and flow control is stored in a stack, which is a data structure characterized by pushing and popping. You push items onto the stack, and then pop those items off. A stack is a last in, first out (LIFO) structure. For example, if you push the numbers 1, 2, and then 3 (in order), the first item to pop off will be 3, because it was the last item pushed onto the stack.

The x86 architecture has built-in support for a stack mechanism. The register support includes the ESP and EBP registers. **ESP is the stack pointer and typically contains a memory address that points to the top of stack. The value of this register changes as items are pushed on and popped off the stack. EBP is the base pointer that stays consistent within a given function, so that the program can use it as a placeholder to keep track of the location of local variables and parameters.**

The stack instructions include push, pop, call, leave, enter, and ret . The stack is allocated in a top-down format in memory, and the highest addresses are allocated and used first. As values are pushed onto the stack, smaller addresses are used. 

![[4_13_01.png]]
![[4_13_02.png]]
![[4_13_03.png]]

The stack is used for short-term storage only. It frequently stores local variables, parameters, and the return address. Its primary usage is for the management of data exchanged between function calls. The implementation of this management varies among compilers, but the most common convention is for local variables and parameters to be referenced relative to EBP.

##### Function Calls
Functions are portions of code within a program that perform a specific task and that are relatively independent of the remaining code. The main code calls and temporarily transfers execution to functions before returning to the main code. How the stack is utilized by a program is consistent throughout a given binary.

**Many functions contain a prologue—a few lines of code at the start of the function. The prologue prepares the stack and registers for use within the function. In the same vein, an epilogue at the end of a function restores the stack and registers to their state before the function was called.**

The following list summarizes the flow of the most common implementation for function calls : 

1. Arguments are placed on the stack using push instructions.

2. A function is called using call memory_location. This causes the current instruction address (that is, the contents of the EIP register) to be pushed onto the stack. This address will be used to return to the main code when the function is finished. When the function begins, EIP is set to memory_location (the start of the function).

3. Through the use of a function prologue, space is allocated on the stack for local variables and EBP (the base pointer) is pushed onto the stack. This is done to save EBP for the calling function.
 
4. The function performs its work.
 
5. Through the use of a function epilogue, the stack is restored. ESP is adjusted to free the local variables, and EBP is restored so that the calling function can address its variables properly. The leave instruction can be used as an epilogue because it sets ESP to equal EBP and pops EBP off the stack.
 
6. The function returns by calling the ret instruction. This pops the return address off the stack and into EIP, so that the program will continue executing from where the original call was made. For example, if you want to begin execution at 0x12345678, you can just do the following:

	![[4_13_04.png]]
 
7. The stack is adjusted to remove the arguments that were sent, unless they’ll be used again later.

**A calling convention is a set of rules dictating how function calls work at the machine level. It is defined by the Application Binary Interface (ABI) for a particular system.** For example, should the parameters be passed through the stack, in registers, or both? Should the parameters be passed in from left-to-right or right-to-left? Should the return value be stored on the stack, in registers, or both? There are many calling conventions, but the popular ones are CDECL, STDCALL, THISCALL, and FASTCALL.

![[4_13_05.png]]


##### Stack Layout
As discussed, the stack is allocated in a top-down fashion, with the higher memory addresses used first. Figure 4-7 shows how the stack is laid out in memory. Each time a call is performed, a new stack frame is generated. A function maintains its own stack frame until it returns, at which time the caller’s stack frame is restored and execution is transferred back to the calling function. 

![[4_13.png]]

 
 Figure 4-8 shows a dissection of one of the individual stack frames from Figure 4-7. The memory locations of individual items are also displayed. In this diagram, ESP would point to the top of the stack, which is the memory address 0x12F02C. EBP would be set to 0x12F03C throughout the duration of the function, so that the local variables and arguments can be referenced using EBP. The arguments that are pushed onto the stack before the call are shown at the bottom of the stack frame. Next, it contains the return address that is put on the stack automatically by the call instruction. The old EBP is next on the stack; this is the EBP from the caller’s stack frame. When information is pushed onto the stack, ESP will be decreased. In the example in Figure 4-8, if the instruction push eax were executed, ESP would be decremented by four and would contain 0x12F028, and the data contained in EAX would be copied to 0x12F028. If the instruction pop ebx were executed, the data at 0x12F028 would be moved into the EBX register, and then ESP would be incremented by four.

![[4_14.png]]

It is possible to read data from the stack without using the push or pop instructions. For example, the instruction **mov eax, ss:[esp]** will directly access the top of the stack. This is identical to pop eax, except the ESP register is not impacted. The convention used depends on the compiler and how the compiler is configured. 
**The x86 architecture provides additional instructions for popping and pushing, the most popular of which are pusha and pushad. These instructions push all the registers onto the stack and are commonly used with popa and popad, which pop all the registers off the stack. The pusha and pushad functions operate as follows:**

- pusha pushes the 16-bit registers on the stack in the following order: AX, CX, DX, BX, SP, BP, SI, DI.
- pushad pushes the 32-bit registers on the stack in the following order: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI.

---

## Conditionals 
All programming languages have the ability to make comparisons and make decisions based on those comparisons. Conditionals are instructions that per form the comparison. **The two most popular conditional instructions are "test" and "cmp"**. 

**The test instruction is identical to the and instruction; however, the operands involved are not modified by the instruction. The test instruction only sets the flags. The zero flag (ZF) is typically the flag of interest after the test instruction.** A test of something against itself is often used to check for NULL values. An example of this is "test eax, eax". **You could also compare EAX to zero, but test eax, eax uses fewer bytes and fewer CPU cycles.**

**The cmp instruction is identical to the sub instruction; however,the operands are not affected. The cmp instruction is used only to set the flags. The zero flag and carry flag (CF) may be changed as a result of the cmp instruction.** Table 4-8 shows how the cmp instruction impacts the flags.

![[4_15.png]]

---

## Branching
A branch is a sequence of code that is conditionally execute depending on the flow of the program. The term branching is used to describe the control flow through the branches of a program. 

The most popular way branching occurs is with jump instructions. An extensive set of jump instructions is used, of which the "jmp" instruction is the simplest. The format **"jmp location"** causes the next instruction executed to be the one specified by the jmp. **This is known as an unconditional jump, because execution will always transfer to the target location.** This simple jump will not satisfy all of your branching needs. For example, the logical equivalent to an if statement isn’t possible with a jmp. There is no if statement in assembly code. **This is where conditional jumps come in. Conditional jumps use the flags to determine whether to jump or to proceed to the next instruction.** More than 30 different types of conditional jumps can be used, but only a small set of them is commonly encountered. Table 4-9 shows the most common conditional jump instructions and details of how they operate.

![[4_16.png]]


---

## Rep Instructions
Rep instructions are a set of instructions for manipulating data buffers. They are usually in the form of an array of bytes, but they can also be single or double words.

The most common data buffer manipulation instructions are movsx, cmpsx, stosx, and scasx, where x = b, w, or d for byte, word, or double word, respectively.

The ESI and EDI registers are used in these operations. ESI is the source index register, and EDI is the destination index register. ECX is used as the counting variable. These instructions require a prefix to operate on data lengths greater than 1 . 

 The movsb instruction will move only a single byte and does not utilize the ECX register. In x86, the repeat prefixes are used for multibyte operations.
 
  The rep instruction increments the ESI and EDI offsets, and decrements the ECX register. The rep prefix will continue until ECX = 0. The   repe/repz and repne/repnz prefixes will continue until ECX = 0 or until the ZF = 1 or 0. This is illustrated in Table 4-10. Therefore, in most data buffer manipulation instructions, ESI, EDI, and ECX must be properly initialized for the rep instruction to be useful.

![[4_17.png]]

The movsb instruction is used to move a sequence of bytes from one location to another. The rep prefix is commonly used with movsb to copy a sequence of bytes, with size defined by ECX. The rep movsb instruction is the logical equivalent of the C memcpy function. **The movsb instruction grabs the byte at address ESI, stores it at address EDI, and then increments or decrements the ESI and EDI registers by one according to the setting of the direction flag (DF). If DF = 0, they are incremented; otherwise, they are decremented. You rarely see this in compiled C code, but in shellcode, people will sometimes flip the direction flag so they can store data in the reverse direction.** If the rep prefix is present, the ECX is checked to see if it contains zero. If not, then the instruction moves the byte from ESI to EDI and decrements the ECX register. This process repeats until ECX = 0. 

The cmpsb instruction is used to compare two sequences of bytes to determine whether they contain the same data. The cmpsb instruction subtracts the value at location EDI from the value at ESI and updates the flags. It is typically used with the repe prefix. When coupled with the repe prefix, the cmpsb instruction compares each byte of the two sequences until it finds a difference between the sequences or reaches the end of the comparison. The cmpsb instruction obtains the byte at address ESI, compares the value at location EDI to set the flags, and then increments the ESI and EDI registers by one. If the repe prefix is present, ECX is checked and the flags are also checked, but if ECX = 0 or ZF = 0, the operation will stop repeating. This is equivalent to the C function memcmp. 

The scasb instruction is used to search for a single value in a sequence of bytes. The value is defined by the AL register. This works in the same way as cmpsb, but it compares the byte located at address ESI to AL, rather than to EDI. The repe operation will continue until the byte is found or ECX = 0. If the value is found in the sequence of bytes, ESI stores the location of that value.

The stosb instruction is used to store values in a location specified by EDI. This is identical to scasb, but instead of being searched for, the specified byte is placed in the location specified by EDI. The rep prefix is used with scasb to initialize a buffer of memory, wherein every byte contains the same value. This is equivalent to the C function memset. Table 4-11 displays some common rep instructions and describes their operation.

![[4_18.png]]

---

x86 supports the concept of privilege separation through an abstraction called ring level. The processor supports four ring levels, numbered from 0 to 3. (Rings 1 and 2 are not commonly used so they are not discussed here.) Ring 0 is the highest privilege level and can modify all system settings. Ring 3 is the lowest privileged level and can only read/modify a subset of system settings. Hence, modern operating systems typically implement user/kernel privilege separaton by having user-mode applications run in ring 3, and the kernel in ring 0. ==The ring level is encoded in the CS register and sometimes referred to as the current privilege level (CPL) in official documentation.==

---

The MOVSB/MOVSW/MOVSD instructions move data with 1-, 2-, or 4-byte granularity between two memory addresses. They implicitly use EDI/ESI as the destination/source address, respectively. In addition, they also automatically update the source/destination address depending on the direction flag ( DF) flag in EFLAGS. If DF is 0, the addresses are decremented; otherwise, they are incremented. These instructions are typically used to implement string or memory copy functions when the length is known at compile time. In some cases, they are accompanied by the REP prefix, which repeats an instruction up to ECX times. Consider the following example:

![[4_19.png]]

---

Another class of data movement instructions with implicit source and destination includes the SCAS and STOS instructions. Similar to MOVS, these instructions can operate at 1-, 2-, or 4-byte granularity. 

- SCAS implicitly compares **AL/AX/EAX** with data starting at the memory address **EDI** register. EDI is automatically incremented/decremented depending on the DF bit in EFLAGS. Given its semantic, SCAS is commonly used along with the REP prefix to find a byte, word, or double-word in a buffer. For example, the C strlen() function can be implemented as follows:

![[4_20.png]]

- STOS is the same as SCAS except that it writes the value AL/AX/EAX to EDI. It is commonly used to initialize a buffer to a constant value (such as memset()). Here is an example:

![[4_21.png]]

![[4_22.png]]

- LODS is another instruction from the same family. It reads a 1-, 2-, or 4-byte value from ESI and stores it in AL, AX, or EAX.

---

### System Mechanism
Lets discuss two fundamental system-level mechanisms: ==virtual address translation== and ==exception/interrupt handling==.

#### Address Translation
The physical memory on a computer system is divided into 4KB units called pages. (A page can be more than 4KB, but we will not discuss the other sizes here.) Memory addresses are divided into two categories: virtual and physical. Virtual addresses are those used by instructions executed in the processor when paging is enabled. For example:

![[4_23.png]]

**Physical addresses are the actual memory locations used by the processor when accessing memory. The processor’s memory management unit (MMU) transparently translates every virtual address into a physical address before accessing it.** While a virtual address may seem like just another number to the user, there is a structure to it when viewed by the MMU. **On x86 systems with physical address extension (PAE) support, a virtual memory address can be divided into indices into three tables and offset: page directory pointer table (PDPT), page directory (PD), page table (PT), and page table entry (PTE). A PDPT is an array of four 8-byte elements, each pointing to a PD. A PD is an array of 512 8-byte elements, each pointing to a PT. A PT is an array of 512 8-byte elements each containing a PTE.** For example, the virtual address 0xBF80EE6B can be understood as shown below.

![[4_24.png]]

The 8-byte elements in these tables contain data about the tables, memory permission, and other memory characteristics. For example, there are bits that determine whether the page is read-only or readable/writable, executable or non-executable, accessible by user or not, and so on.

**The address translation process revolves around these three tables and the CR3 register. CR3 holds the physical base address of the PDPT.** 

Lets see a walk through the translation of the virtual address 0xBF80EE6B on a real system (refer to Figure above):

![[4_25.png]]

Per the documentation, the bottom 12 bits of a PDPT entry are flags/reserved bits, and the remaining ones are used as the physical address of the PD base. Bit 63 is the NX flag in PAE, so you will also need to clear that as well. In this particular example, we did not clear it because it is already 0. (We are looking at code pages that are executable.)

![[4_26.png]]

Again, per the documentation, the bottom 12 bits of a PD entry are used for flags/reserved bits, and the remaining ones are used as the base for the PT:

![[4_27.png]]

Again, the bottom 12 bits can be cleared to get to the base of a page entry:

![[4_28.png]]

After the entire process, it is determined that the virtual address 0xBF80EE6B translates to the physical address 0x6694E6B. 

Modern operating systems implement process address space separation using this mechanism. Every process is associated with a different CR3, resulting in process-specific virtual address translation. It is the magic behind each process’s illusion that it has its own address space. 

#### Interrupts and Exceptions
In contemporary computing systems, the processor is typically connected to peripheral devices through a data bus such as PCI Express, FireWire, or USB. When a device requires the processor’s attention, it causes an interrupt that forces the processor to pause whatever it is doing and handle the device’s request. How does the processor know how to handle the request? At the highest level,
one can think of an interrupt as being associated with a number that is then used to index into an array of function pointers. When the processor receives the interrupt, it executes the function at the index associated with the interrupt and resumes execution at wherever it was before the interrupt occurred. These are called hardware interrupts because they are generated by hardware devices. They are asynchronous by nature.


[[5_x64_Assembly|See x64 Assembly]]