## Whirlwind tour through the various malware behaviors

#### 1. Downloaders and Launchers
Two commonly encountered types of malware are downloaders and launchers. Downloaders simply download another piece of malware from the Internet and execute it on the local system. Downloaders are often packaged with an exploit. Downloaders commonly use the Windows API ==URLDownloadtoFileA==, followed by a call to ==WinExec== to download and execute new malware.

A launcher (also known as a loader) is any executable that installs malware
for immediate or future covert execution. Launchers often contain the
malware that they are designed to load.

---

#### 2. Backdoors
A backdoor is a type of malware that provides an attacker with remote access to a victim’s machine. Backdoor code often implements a full set of capabilities, so when using a backdoor attackers typically don’t need to download additional malware or code.

Backdoors come with a common set of functionality, such as the ability
to manipulate registry keys, enumerate display windows, create directories,
search files, and so on. You can determine which of these features is implemented by a backdoor by looking at the Windows functions it uses and
imports.

---

#### 3. Reverse Shell
A reverse shell is a connection that originates from an infected machine and provides attackers shell access to that machine. Reverse shells are found as both stand-alone malware and as components of more sophisticated backdoors. Once in a reverse shell, attackers can execute commands as if they were on the local system.

##### Windows Reverse Shells
Attackers employ two simple malware coding implementations for reverse
shells on Windows using cmd.exe: basic and multithreaded. 

The basic method is popular among malware authors, since it’s easier to write and generally works just as well as the multithreaded technique. It involves a call to ==CreateProcess== and the manipulation of the ==STARTUPINFO== structure that is passed to CreateProcess. First, a socket is created and a connection to a remote server is established. That socket is then tied to the standard streams (standard input, standard output, and standard error) for cmd.exe. CreateProcess runs cmd.exe with its window suppressed, to hide it from the victim.

The multithreaded version of a Windows reverse shell involves the creation of a socket, two pipes, and two threads (so look for API calls to CreateThread and CreatePipe). This method is sometimes used by malware authors as part of a strategy to manipulate or encode the data coming in or going out over the socket. CreatePipe can be used to tie together read and write ends to a pipe, such as standard input (stdin) and standard output (stdout). The CreateProcess method can be used to tie the standard streams to pipes instead of directly to the sockets. After CreateProcess is called, the malware will spawn two threads: one for reading from the stdin pipe and writing to the socket, and the other for reading the socket and writing to the stdout pipe.

---

#### 4. RATs
A RAT (Remote Administration Tool | Remote Access Trojan) is used to remotely manage a computer or  computers. RATs are often used in targeted attacks with specific goals, such  as stealing information or moving laterally across a network.

---

#### 5. Botnets
A botnet is a collection of compromised hosts, known as zombies, that are controlled by a single entity, usually through the use of a server known as a botnet  controller. The goal of a botnet is to compromise as many hosts as possible in  order to create a large network of zombies that the botnet uses to spread  additional 

**RATs and Botnets Compared**
There are a few key differences between botnets and RATs:

- Botnets have been known to infect and control millions of hosts. RATs typically control far fewer hosts.
- All botnets are controlled at once. RATs are controlled on a per-victim basis because the attacker is interacting with the host at a much more intimate level.
- RATs are used in targeted attacks. Botnets are used in mass attacks.

---

#### 6. Credential Stealers

Attackers often go to great lengths to steal credentials, primarily with three types of malware:

- Programs that wait for a user to log in in order to steal their credentials
- Programs that dump information stored in Windows, such as password hashes, to be used directly or cracked offline
 - Programs that log keystrokes

Read From Page 268 to 271 For More Understanding

---

#### 7. Keystroke Logging
Keylogging is a classic form of credential stealing. When keylogging, malware records keystrokes so that an attacker can observe typed data like usernames and passwords. Windows malware uses many forms of keylogging.

###### Kernel-Based Keyloggers
Kernel-based keyloggers are difficult to detect with user-mode applications. They are frequently part of a rootkit and they can act as keyboard drivers to capture keystrokes, bypassing user-space programs and protections.

###### User-Space Keyloggers
Windows user-space keyloggers typically use the Windows API and are usually implemented with either **hooking or polling**. 

Hooking uses the  Windows API to notify the malware each time a key is pressed, typically with the ==SetWindowsHookEx== function. Polling uses the Windows API to constantly poll the state of the keys, typically using the ==GetAsyncKeyState== and ==GetForegroundWindow== functions.


The GetAsyncKeyState function identifies whether a key is pressed or depressed, and whether the key was pressed after the most recent call to GetAsyncKeyState. The GetForegroundWindow function identifies the foreground window—the one that has focus—which tells the keylogger which application is being used for keyboard entry (Notepad or Internet Explorer, for example).

---
---

#### Persistence Mechanisms
Once malware gains access to a system, it often looks to be there for a long time. This behavior is known as persistence.

The most commonly achieved method of persistence:
- Modification of the system’s registry.
- Modification of files for persistence through a process known a **trojanizing binaries.**
- Persistence without modifying the registry or files, known as **DLL load-order hijacking.**

###### The Windows Registry
the Windows registry is common for malware to access the registry to store configuration information, gather information about the system, and install itself persistently. The following registry key is a popular place for malware to install itself:

>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run

There are a couple popular registry entries that are worth expanding on further : **AppInit_DLLs, Winlogon, and SvcHost DLLs.**

1. **AppInit_DLLs**
Malware authors can gain persistence for their DLLs though a special registry location called AppInit_DLL. **AppInit_DLLs are loaded into every process that loads User32.dll, and a simple insertion into the registry will make AppInit_DLLs persistent.**

The AppInit_DLLs value is stored in the following Windows registry key:

> HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows

The AppInit_DLLs value is of type REG_SZ and consists of a space-delimited string of DLLs. Most processes load User32.dll, and all of those processes also load the AppInit_DLLs. Malware authors often target individual processes, but AppInit_DLLs will be loaded into many processes. Therefore, malware authors must check to see in which process the DLL is running before executing their payload. This check is often performed in DllMain of the malicious DLL.


2. **Winlogon Notify**
Malware authors can hook malware to a particular Winlogon event, such as logon, logoff, startup, shutdown, and lock screen. This can even allow the malware to load in safe mode. The registry entry consists of the Notify value in the following registry key:

> HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\

When winlogon.exe generates an event, Windows checks the Notify registry key for a DLL that will handle it.

